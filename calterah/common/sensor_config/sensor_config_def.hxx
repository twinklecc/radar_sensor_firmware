
/*
 This file is automatically generated by sesnor_code_gen.py. Please do not check in any manual changes!
 */
        double fmcw_startfreq;                             /* start frequency in GHz */
        double fmcw_bandwidth;                             /* bandwidth in MHz */
        float fmcw_chirp_rampup;                           /* chirp ramp up time in us */
        float fmcw_chirp_down;                             /* chirp ramp down time in us */
        float fmcw_chirp_period;                           /* chirp period in us */
        int32_t nchirp;                                    /* num of chirps per frame */
        uint32_t adc_freq;                                 /* ADC sampling freq in MHz */
        uint32_t dec_factor;                               
        float adc_sample_start;                            /* chirp sampling start offset in us */
        float adc_sample_end;                              /* chirp sampling end offset in us */
        uint32_t tx_groups[MAX_NUM_TX];                    /* each element in tx_groups denotes the tx_antenna work state in four-chirp period. First nibble (LSB) denotes the first chirp, forth nibble denotes the forth chirp. Nibble value: 0:off, 1: in phase,  2: opposite phase, 3 and above: reserved */
        char rng_win[16];                                  /* range window type: cheb or square */
        char vel_win[16];                                  /* velocity window type: cheb or square */
        float rng_win_params[3];                           /* range window parameters */
        float vel_win_params[3];                           /* velocity window parameters */
        uint32_t rng_nfft;                                 /* FFT size of range gate */
        uint32_t vel_nfft;                                 /* FFT size of Doppler gate */
        uint32_t rng_fft_scalar;                           /* FFT scaling control of range gate FFT */
        uint32_t vel_fft_scalar;                           /* FFT scaling control of velocity gate FFT */
        bool fft_nve_bypass;                               /* FFT NVE mode */
        uint32_t fft_nve_shift;                            /* FFT NVE more shift */
        uint32_t fft_nve_ch_mask;                          /* FFT NVE channel mask */
        float fft_nve_default_value;                       /* FFT NVE default value, take effect only when NVE is bypassed */
        uint32_t cfar_pk_en;                               /* peak enabler bit mask */
        uint32_t cfar_pk_win_size1[CFAR_MAX_GRP_NUM];      /* peak detector sliding window size1 */
        uint32_t cfar_pk_win_size2[CFAR_MAX_GRP_NUM];      /* peak detector sliding window size2 */
        uint32_t cfar_pk_threshold[CFAR_MAX_GRP_NUM];      /* exponent threshold for CUT to be considered as object candidate. The larger the value, the lower the threshold is. maximum value is 31 */
        uint32_t cfar_sliding_win;                         /* CFAR sliding window type, 0: retangle, 1: cross */
        uint32_t cfar_recwin_decimate;                     /* decimating scheme for rectangle window, 00b: no decimation, 10b: dopper, 01b: range, 11b: both dimensions */
        uint32_t cfar_recwin_msk[CFAR_MAX_RECWIN_MSK_LEN]; /* Rectangular Window mask. 11x8 elements in total. First 11 elements defines the rectangular mask for first region. 2nd 11 elements are for 2nd region */
        uint32_t cfar_region_algo_type;                    /* CFAR per sub-region CFAR Algo type bitMsk for 8 sub-groups. 00b: CA-CFAR 01b: OS-CFAR 10b: SOGO-CFAR 11b: NR-CFAR */
        float cfar_os_rnk_ratio[CFAR_MAX_GRP_NUM];         /* The scalar of related rank */
        uint32_t cfar_os_rnk_sel[CFAR_MAX_GRP_NUM];        /* The mux control to select the final source of rank threshold, 0:tdec, 1: ratio * number of RCs */
        uint32_t cfar_os_tdec[CFAR_MAX_GRP_NUM];           /* The deterministic  rank threshold */
        float cfar_os_alpha[CFAR_MAX_GRP_NUM];             /* The scalar of CUT power before ranking */
        uint32_t cfar_combine_dirs;                        /* # of combining directions. Value 0 means non-coherent combination */
        float cfar_combine_thetas[MAX_CFAR_DIRS];          /* predefined combining directions of azimuth */
        float cfar_combine_phis[MAX_CFAR_DIRS];            /* predefined combining directions of elevation */
        uint32_t cfar_crswin_rng_size;                     /* cross window length alone range-gate */
        uint32_t cfar_crswin_rng_skip;                     /* cross window guard size alone range-gate */
        uint32_t cfar_crswin_vel_size;                     /* cross window length alone velocity-gate */
        uint32_t cfar_crswin_vel_skip;                     /* cross window guard size alone velocity-gate */
        char cfar_mimo_win[16];                            /* MIMO CFAR window type */
        float cfar_mimo_win_params[3];                     /* MIMO CFAR window parameter */
        uint32_t cfar_noise_type;                          /* 8 region noise level output select register: 1 from CFAR local estimation; 0: from NVE */
        float cfar_nr_alpha[CFAR_MAX_GRP_NUM];             /* Scalar of power of CUT before comparison or ranking */
        float cfar_nr_beta1[CFAR_MAX_GRP_NUM];             /* Lower bound scalar in construction of set of reference powers */
        float cfar_nr_beta2[CFAR_MAX_GRP_NUM];             /* Upper bound scalar in construction of set of reference powers */
        float cfar_nr_rnk_ratio[CFAR_MAX_GRP_NUM];         /* The scalar of related rank */
        uint32_t cfar_nr_rnk_sel[CFAR_MAX_GRP_NUM];        /* The mux control to select the final source of rank threshold in scheme 2 */
        uint32_t cfar_nr_scheme_sel[CFAR_MAX_GRP_NUM];     /* Select output from one of three schemes */
        uint32_t cfar_nr_tdec[CFAR_MAX_GRP_NUM];           /* Pre-programmed Rank threshold for scheme 2 */
        uint32_t cfar_region_sep_rng[3];                   /* RDM region partition in range dimension */
        uint32_t cfar_region_sep_vel[8];                   /* RDM region partition in velocity dimension */
        float cfar_sogo_alpha[CFAR_MAX_GRP_NUM];           /* The scalar of CUT's power before comparison */
        uint32_t cfar_sogo_i[CFAR_MAX_GRP_NUM];            /* The i-th smallest over the averages from selected sides */
        uint32_t cfar_sogo_mask[CFAR_MAX_GRP_NUM];         /* The mask control to select the sides of the cross window; bit0: negative range direction; bit1: positive range direction; bit2: negative velocity direction; bit3: positive velocity direction */
        float cfar_ca_alpha[CFAR_MAX_GRP_NUM];             /* Scalar of CUT power before comparing */
        uint32_t cfar_ca_n[CFAR_MAX_GRP_NUM];              /* Number of maximum to remove before averaging */
        uint32_t doa_mode;                                 /* 2D_doa_mode 0/normal mode 1/combined mode 2/single shot mode */
        uint32_t doa_num_groups;                           /* bfm 2d on/off */
        uint32_t doa_fft_mux[MAX_BFM_GROUP_NUM];           /* normal mode/single shot mode doa rx antenna mux */
        uint32_t combined_doa_fft_mux[4];                  /* combined mode doa rx antenna mux */
        uint32_t doa_method;                               /* selection bit for doa method 0-digital bfm 2-DML */
        uint32_t doa_npoint[MAX_BFM_GROUP_NUM];            /* # of testing point of BFM/DML */
        char doa_samp_space;                               /* doa sampling space. t: uniformly sampling in theta, u: uniformly sampling in sin(theta) */
        uint32_t doa_max_obj_per_bin[MAX_BFM_GROUP_NUM];   /* Max # of objects per bin */
        float bfm_peak_scalar[3];                          /* Non/IPM mode peak scalar */
        float bfm_noise_level_scalar[3];                   /* multiobject noise level scalar for different SNR regime */
        uint32_t bfm_snr_thres[2];                         /* multiobject SNR regime threshold */
        float bfm_az_left;                                 /* Left limit of BFM azimuth angle */
        float bfm_az_right;                                /* Right limit of BFM azimuth angle */
        float bfm_ev_up;                                   /* Up limit of BFM elevated angle */
        float bfm_ev_down;                                 /* Down limit of BFM elevated angle */
        char doa_win[16];                                  /* BFM window type */
        float doa_win_params[3];                           /* BFM window parameter */
        uint32_t bfm_raw_search_step;                      /* raw search step for dbf work in OMP/IMP mode. Value 1 disables fine search */
        uint32_t bfm_fine_search_range;                    /* fine search range for dbf work in OMP/IMP mode */
        bool bfm_iter_search;                              /* enable bit for iterative search for dbf */
        uint32_t bfm_mode;                                 /* 1: OMP; 0: IPM */
        uint32_t bfm_group_idx;                            /* group index when DBF works in single shot mode 0-azimuth 1-elevated 2-aided */
        bool ant_info_from_flash;                          /* whether taking antenna position/compensation from flash */
        uint32_t ant_info_flash_addr;                      /* Starting address where antenna postion/comp on flash */
        antenna_pos_t ant_pos[MAX_ANT_ARRAY_SIZE];         /* unit in wavelength */
        float ant_comps[MAX_ANT_ARRAY_SIZE];               /* unit in deg */
        bool bpm_mode;                                     /* BPM mode */
        uint8_t phase_scramble_on;                         /* phase scramble mode */
        uint32_t phase_scramble_init_state;                /* phase scramble mode init state */
        uint32_t phase_scramble_tap;                       /* phase scramble mode tap value */
        float phase_scramble_comp[4];                      /* phase compensation angle */
        uint8_t freq_hopping_on;                           /* frequency hopping mode */
        uint32_t freq_hopping_init_state;                  /* frequency hopping mode init state */
        uint32_t freq_hopping_tap;                         /* frequency hopping mode tap value */
        float freq_hopping_deltaf;                         /* frequency hopping, delta frequency, MHz */
        uint8_t chirp_shifting_on;                         /* chirp shifting mode */
        uint32_t chirp_shifting_init_state;                /* chirp shifting mode init state */
        uint32_t chirp_shifting_init_tap;                  /* chirp shifting mode tap  value */
        float chirp_shifting_delay;                        /* chirp shifting mode delay, us */
        bool fsm_on;                                       /* function safety on/off */
        int32_t agc_mode;                                  /* AutoGainCtrl mode on/off */
        uint32_t agc_code[AGC_CODE_ENTRY_NUM];             /* store AGC_init_gain and clip1 and clip2 table bit0 LNA */
        float agc_tia_thres;                               /* threshold for saturation decision of TIA */
        float agc_vga1_thres;                              /* threshold for saturation decision of VGA1 */
        float agc_vga2_thres;                              /* threshold for saturation decision of VGA2 */
        bool agc_align_en;                                 /* AGC align mode on/off */
        bool adc_comp_en;                                  /* If enable adc compensation by left shifting when agc mode is on */
        uint8_t rf_tia_gain;                               /* TIA gain */
        uint8_t rf_vga1_gain;                              /* VGA1 gain */
        uint8_t rf_vga2_gain;                              /* VGA2 gain */
        uint8_t rf_hpf1;                                   /* Highpass 1 setting */
        uint8_t rf_hpf2;                                   /* Highpass 2 setting */
        bool de_vel_amb;                                   /* velocity ambiguity on/off (multi-frame) */
        uint8_t track_fps;                                 /* Frame per second */
        float track_fov_az_left;                           /* angle threshold to drop unstable objects in deg */
        float track_fov_az_right;                          /* angle threshold to drop unstable objects in deg */
        float track_fov_ev_down;                           /* angle threshold to drop unstable objects in deg */
        float track_fov_ev_up;                             /* angle threshold to drop unstable objects in deg */
        float track_near_field_thres;                      /* threshold to drop unstable near-field objects in meter */
        float track_capture_delay;                         /* time delay between first appear and stable tracking in second */
        float track_drop_delay;                            /* time delay between first missing and tracking drop in second */
        float track_vel_pos_ind_portion;                   /* portion of velocity indices are used for positive velocity */
        uint8_t track_obj_snr_sel;                         /* select object SNR type for track - 0: Ratio of DoA peak power to noise / 1: Ratio of RXs FFT average power to noise/ 2: absolute RXs FFT average power in dB */
        uint32_t tx_phase_value[4];                        /* Tx phase value for each Channel - 0 / 22 / 45 / 67 / 90 / 112 / 135 / 157 / 180 / 202 / 225 / 247 / 270 / 292 / 315 / 337 */
        bool spk_en;                                       /* enable interference mitigation */
        uint8_t spk_buf_len;                               /* buffer length for detecting spikes */
        bool spk_set_zero;                                 /* set spikes to zero */
        uint8_t spk_ovr_num;                               /* overflow samples threshold to claim spike is detected */
        bool spk_thres_dbl;                                /* double threshold for detecting spikes */
        bool spk_min_max_sel;                              /* choose smaller estimated d_max */
        bool zero_doppler_cancel;                          /* remove static objects from 2DFFT results */
        bool anti_velamb_en;                               /* velocity de-ambiguity (chirp delay mode) */
        uint32_t anti_velamb_delay;                        /* velocity de-ambiguity: delay between the extra chirp and normal chirp in virtual group 0 */
        int32_t anti_velamb_qmin;                          /* velocity de-ambiguity: minium ambiguity factor */
        bool high_vel_comp_en;                             /* compensate range and velocity when object speed is high */
        uint8_t high_vel_comp_method;                      /* method of compensation - 0: compensate automatically  1: compensate by user defined value */
        float vel_comp_usr;                                /* user defined compensation value for velocity */
        float rng_comp_usr;                                /* user defined compensation value for range */
        uint32_t dml_2dsch_start[2];                       /* dml: starting point of angle searching */
        uint32_t dml_2dsch_step[2];                        /* dml: pace of coarse searching */
        uint32_t dml_2dsch_end[2];                         /* dml: ending point of angle searching */
        bool dml_extra_1d_en[2];                           /* dml: enabler for the extra 1d-dml */
        bool dml_p1p2_en[2];                               /* dml: enabler for coef2 and coef3 in RNE */
        float dml_respwr_coef[10];                         /* dml: coefficients for RNE */
        bool acc_rng_hw;                                   /* knob for range interpolation after CFAR for accuracy improvement */
        bool acc_vel_hw;                                   /* knob for velocity interpolation after CFAR for accuracy improvement */
        bool acc_angle_hw;                                 /* knob for angle interpolation after DBF for accuracy improvement */
        uint8_t cas_obj_merg_typ;                          /* cascade master and slave object infos merge type - 0: and merge/ 1: loose and merge/ 2: slave based merge */
        bool sv_read_from_flash;                           /* read steering vector from flash or generate sv from ant_pos - FALSE: sv from ant_pos/ TRUE: sv from flash */